# **CityInfoAPI - ASP.NET Core 8**

## **Project Overview**

CityInfoAPI is a RESTful API built using C# and ASP.NET Core 8 to manage a cities info. The API follows the MVC approach, implementing CRUD operations (POST, GET, PUT, DELETE) with concepts such as route groups, input validation, extension methods, data transfer objects (DTO), dependency injection, singleton pattern, securing and documenting the API, testing and deploying the API.

The project utilizes SQL Server with ASP.NET configuration and .NET Secret Manager to securely connect the API to the database. Entity Framework Core is employed as the ORM (Object-Relational Mapping) tool to facilitate querying and modifying the database using C# language. Additionally, the asynchronous programming model is adopted to enhance API performance and scalability.

## **Module 1: Getting Acquainted with ASP.NET Core**

- Introduction to ASP.NET Core:
  - Cross-platform, high-performance, open-source framework.
  - Designed for building modern, cloud-enabled, internet-connected applications.
- Versioning and Platform:
  - Initially ran on .NET Core platform.
  - .NET Core later renamed to .NET.
  - Skipped version 4 to avoid confusion with older full .NET framework.
  - Current state: ASP.NET Core 8 running on .NET 8.
- Creating ASP.NET Core Web Application:
  - Program class is the starting point, with the main method generated by the compiler.
  - The generated main method configures and runs the application.
  - Web application requires hosting; a web application builder is used.
  - Services collection on the builder allows adding and configuring services.
  - Services are added to the built-in dependency injection container.
  - Web application is built, resulting in an object of type WebApplication, implementing IApplicationBuilder.
  - IApplicationBuilder instances configure an application's request pipeline.
- Request Pipeline Configuration:
  - Components handling HTTP requests are called middleware.
  - Middleware can be scoped to different environments.
  - Middleware configuration defines how the application responds to individual HTTP requests.

## **Module 2: Creating the API and Returning Resources**

- Clarifying MVC Pattern:
  - MVC stands for Model View Controller.
  - Model: Handles application data logic.
  - View: Represents parts displaying data, typically in JSON format for APIs.
  - Controller: Manages interaction between View and Model.
  - Promotes reuse and better testability.
- HTTP Methods in API:
  - Use GET to retrieve data.
  - Routing maps request URI to controller method.
  - Other methods: POST for creating, PUT for updates, PATCH for partial updates, DELETE for deletion.
- Routing in APIs:
  - Attribute-based routing recommended over convention-based routing.
- Content Negotiation:
  - Process of selecting the best representation for a response.
  - Formatters handle serialization.
  - Media type in the Accept header value drives content negotiation.
- Returning Files:
  - Use ControllerBase method File for returning files.
  - Set correct media type on the response to inform the operating system.

## **Module 3: Manipulating Resources and Validating Input**

- Learning about POST for creating a resource:
  - Successful creation results in a 201 Created status code response.
  - First instance of submitting a request body to the API.
  - Request body format determined by the Contentâ€‘Type header.
- Input validation:
  - Introduction to input validation and data annotations on DTO classes.
  - Checking validation rules using ModelState, a dictionary containing model and model-binding validation state.
  - ModelState.IsValid property indicating validation success.
  - ApiController attribute automatically returns a Bad Request for validation failures.
- Updating a resource:
  - PUT for full updates, PATCH for partial updates.
  - JasonPatch standard for expressing a sequence of operations for partial updates.
  - Successful update response: No Content (204) or OK (200) status code.
- Deleting resources:
  - DELETE method used for resource deletion.
  - Successful deletion warrants a 204 status code.
- File uploads:
  - File uploads handled with POST method.
  - IFormFile class used to accept file uploads as a parameter.
  - Caution emphasized for supporting file uploads due to potential risks.

## **Module 4: Working with Services and Dependency Injection**

- Dependency Injection in ASP.NET Core:
  - Built-in dependency injection system.
  - Specialization of the inversion of control pattern.
  - Uses a container to initialize objects and provide required dependencies.
  - Loose coupling advantages: fewer code changes, better testability.
- Logging Functionality:
  - Implementation of logging using the built-in logger service.
  - Registration of custom services on the built-in container in the Program class.
- Service Lifetimes:
  - Transient lifetime: Created each time requested; suitable for lightweight, stateless services.
  - Scoped lifetime: Created once per request.
  - Singleton lifetime: Created the first time requested, subsequent requests use the same instance.
- Dependency Injection Usage:
  - Registering services on the container.
  - Injecting services using dependency injection into classes requiring instances.
- Configuration Files:
  - Use IConfiguration object to access configuration values.
  - Environment-specific configuration files by adding the environment name to the file name.

## **Module 5: Getting Acquainted with Entity Framework Core**

- Introduction to Entity Framework Core:
  - Entity Framework Core (EF Core) as an object-relational mapper (ORM).
  - Object-relational mapping allows querying and manipulating data using an object-oriented paradigm.
  - EF Core is the preferred ORM for .NET.
- Entity Classes vs DTOs:
  - Entity classes represent the data model for the underlying database.
  - Distinction between DTOs (outer-facing model) and entities (inner model).
  - Annotations or conventions used to define aspects like Primary and Foreign Keys.
- DbContext and DbSets:
  - DbContext represents a session with the database.
  - DbSets registered on DbContext to represent sets of entities.
  - LINQ used to query and save instances of entities.
- Migrations:
  - Database evolves with code changes.
  - Migrations provide code to change the database from one version to another.
  - Allows adding, dropping, or altering tables.
- Seeding the Database:
  - Use the hasData method when configuring the model to seed the database.
  - Ensure to add a migration after configuring the model.
- Connection String Handling:
  - Transition from hard-coded connection string to a more flexible approach.
  - Store connection string in appsettings file for Development, and use Environment variables for Production.
- SQL Injection Considerations:
  - Entity Framework Core provides protection against SQL injection.
  - Caution advised when using .FromSqlRaw; potential vulnerabilities.

## **Module 6: Using Entity Framework Core in Your Controllers**

- Repository Pattern:
  - Introduction to the repository pattern.
  - Accessing the database via Entity Framework Core using the repository pattern.
  - Understanding the benefits of async code in database operations.
- Replacement of In-memory Datastore:
  - Replacing code utilizing the current in-memory datastore with code for persistent store, i.e., the database.
- Introduction of AutoMapper:
  - Introduction to AutoMapper.
  - Purpose: Mapping between DTOs and Entity classes.
  - Necessity due to distinct purposes served by DTOs and Entity classes.
- Module Objective:
  - Aim for a fully-functional API connected to a database via Entity Framework Core.
  - Upon completion, the API will effectively utilize the repository pattern, async code, and AutoMapper.

## **Module 7: Searching, Filtering, and Paging Resources**

- Understanding Filtering and Searching:
  - Introduction to filtering and searching concepts.
  - Differentiating between the two and their significance in API functionality.
- Implementation of Filtering and Searching:
  - Step-by-step implementation of filtering and searching support in the API.
  - Techniques and methods for effectively filtering and searching resource collections.
- Introduction to Paging:
  - Explanation of paging and its importance in managing large resource collections.
  - Overview of paging strategies and techniques.
- Implementation of Paging:
  - Detailed implementation of paging functionality in the API.
  - Techniques for efficient paging through resource collections.
- Module Objective:
  - Mastery of filtering, searching, and paging functionalities in API development.
  - Practical implementation of these functionalities to enhance API usability and performance.

## **Module 8: Securing Your API**

- Understanding API Security Options:
  - Introduction to various options for securing an API.
  - Discussion on choosing token-based security as the preferred option.
- Implementation of Token-based Security:
  - Step-by-step implementation of token-based security.
  - Creation, enforcement, and validation of tokens in the API.
- Utilizing Token Information:
  - Learning how to extract user information and claims from tokens.
  - Understanding the usage of token information in controllers and authorization policies.
- Introduction to Authorization Policies:
  - Explanation of authorization policies and their role in API security.
  - Implementation of authorization policies for controlling access to API resources.
- Integration of OAuth2 and OpenID Connect:
  - Overview of OAuth2 and OpenID Connect in API security.
  - Understanding the role of OAuth2 and OpenID Connect in enhancing API security.
- Module Objective:
  - Mastery of token-based security implementation in APIs.
  - Understanding of authorization policies and their usage.
  - Familiarity with OAuth2 and OpenID Connect in API security.

## **Module 9:Versioning and Documenting Your API**

- Importance of API Versioning:
  - Understanding the significance of API versioning.
  - Discussion on different approaches to API versioning.
- Implementation of API Versioning:
  - Step-by-step implementation of API versioning.
  - Exploration of various versioning strategies and their implementation.
- Introduction to API Documentation:
  - Explanation of API documentation and its importance.
  - Introduction to OpenAPI and Swagger UI for generating documentation.
- Enhancing API Documentation:
  - Learning how to improve API documentation using OpenAPI and Swagger UI.
  - Incorporating XML comments, status codes, and authentication details into documentation.
- Module Objective:
  - Mastery of API versioning techniques and implementation.
  - Understanding of API documentation principles and tools.
  - Practical skills in enhancing API documentation for better usability.

## **Module 10:Testing and Deploying Your API**

- API Endpoint Testing Options:
  - Exploration of testing options for API endpoints.
  - Introduction to tools like Postman, HttpRepl, and .http-files in Visual Studio.
- Testing API Endpoints:
  - Practical demonstration of testing API endpoints using various tools.
  - Comparison of testing methodologies and their effectiveness.
- Hosting and Deployment Options:
  - Overview of hosting and deployment options for ASP.NET Core Web API.
  - Discussion on deploying to Azure and other hosting platforms.
- Deployment to Azure:
  - Step-by-step guide to deploying the API to Azure.
  - Explanation of forwarded headers middleware and its significance.
- Logging on Azure using Application Insights:
  - Integration of Application Insights for logging on Azure.
  - Implementation of logging strategies for monitoring API performance.
- Safely Storing Secrets in Azure Key Vault:
  - Explanation of Azure Key Vault and its role in storing secrets securely.
  - Implementation of secret management using Azure Key Vault.
- Module Objective:
  - Mastery of API endpoint testing methodologies.
  - Understanding of hosting and deployment options for ASP.NET Core Web API.
  - Practical skills in deploying to Azure and managing secrets securely.
